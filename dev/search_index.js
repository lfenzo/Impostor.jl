var documenterSearchIndex = {"docs":
[{"location":"providers/finance/#Finance","page":"Finance","title":"Finance","text":"","category":"section"},{"location":"providers/finance/","page":"Finance","title":"Finance","text":"The following generator functions are available in the Finance provider:","category":"page"},{"location":"providers/finance/","page":"Finance","title":"Finance","text":"bank_name\nbank_official_name\ncredit_card_cvv\ncredit_card_expiry\ncredit_card_number\ncredit_card_vendor","category":"page"},{"location":"providers/finance/#Impostor.bank_name","page":"Finance","title":"Impostor.bank_name","text":"bank_name(n::Integer = 1; kwargs...)\nbank_name(options::Vector, n::Integer; level::Symbol, kwargs...)\nbank_name(mask::Vector; level::Symbol, kwargs...)\n\nParameters\n\nn::Integer = 1: number of bank name entries to generate\noptions::Vector{<:AbstractString}: vector with options restricting the possible values generated.\nmask::Vector{<:AbstractString}: mask vector with element-wise option restrictions.\n\nKwargs\n\nlevel::Symbol = :bank_code: Level of values in options or mask when using option-based or mask-based eneration.\nlocale::Vector{String}: locale(s) from which entries are sampled. If no locale is provided, the current session locale is used.\n\nExample\n\njulia> bank_name(5; locale = [\"pt_BR\"])\n5-element Vector{String}:\n \"Broker\"\n \"Nubank\"\n \"Itaubank\"\n \"Renascenca\"\n \"Daycoval\"\n\n\n\n\n\n","category":"function"},{"location":"providers/finance/#Impostor.bank_official_name","page":"Finance","title":"Impostor.bank_official_name","text":"bank_official_name(n::Integer = 1; kwargs...)\nbank_official_name(options::Vector, n::Integer; level::Symbol, kwargs...)\nbank_official_name(mask::Vector; level::Symbol, kwargs...)\n\nParameters\n\nn::Integer = 1: number of official bank name entries to generate\noptions::Vector{<:AbstractString}: vector with options restricting the possible values generated.\nmask::Vector{<:AbstractString}: mask vector with element-wise option restrictions.\n\nKwargs\n\nlevel::Symbol = :bank_code: Level of values in options or mask when using option-based or mask-based eneration.\nlocale::Vector{String}: locale(s) from which entries are sampled. If no locale is provided, the current session locale is used.\n\nExample\n\n```jldoctest\n\n\n\n\n\n","category":"function"},{"location":"providers/finance/#Impostor.credit_card_cvv","page":"Finance","title":"Impostor.credit_card_cvv","text":"credit_card_cvv(n::Integer = 1; kwargs...)\n\nGenerate n credit card ccvs, e.g. 034\n\n\n\n\n\n","category":"function"},{"location":"providers/finance/#Impostor.credit_card_expiry","page":"Finance","title":"Impostor.credit_card_expiry","text":"credit_card_expiry(n::Integer = 1; kwargs...)\n\nGenerate n credit card expiry entries, e.g. 05/2029.\n\n\n\n\n\n","category":"function"},{"location":"providers/finance/#Impostor.credit_card_number","page":"Finance","title":"Impostor.credit_card_number","text":"credit_card_number(n::Integer = 1; kwargs...)\ncredit_card_number(options::Vector{<:AbstractString}, n::Integer; kwargs...)\ncredit_card_number(mask::Vector{<:AbstractString}; kwargs...)\n\nParameters\n\nn::Integer = 1: number of credit card numbers to generate.\noptions::Vector{<:AbstractString}: vector with options restricting the possible values generated.\nmask::Vector{<:AbstractString}: mask vector with element-wise option restrictions.\n\nKwargs\n\nformatted::Bool: whether to return the raw credit card numbers e.g. \"3756808757861311\" or to format the output e.g. \"3756-8087-5786-1311\"\n\n\n\n\n\n","category":"function"},{"location":"providers/finance/#Impostor.credit_card_vendor","page":"Finance","title":"Impostor.credit_card_vendor","text":"credit_card_vendor(n::Integer = 1; kwargs...)\ncredit_card_vendor(options::Vector{<:AbstractString}, n::Integer; kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"providers/finance/","page":"Finance","title":"Finance","text":"","category":"page"},{"location":"providers/identity/#Identity","page":"Identity","title":"Identity","text":"","category":"section"},{"location":"providers/identity/","page":"Identity","title":"Identity","text":"The following generator functions are available in the Identity provider:","category":"page"},{"location":"providers/identity/","page":"Identity","title":"Identity","text":"prefix\nbirthdate\nbloodtype\ncomplete_name\nhighschool\nnationality\nuniversity\noccupation\nfirstname\nsurname","category":"page"},{"location":"providers/identity/#Impostor.prefix","page":"Identity","title":"Impostor.prefix","text":"prefix(n::Integer = 1; kwargs...)\nprefix(options::Vector{String}, n::Integer; kwargs...)\nprefix(mask::Vector{<:AbstractString}; kwargs...)\n\nGenerate n name prefixes, e.g. \"Mr.\" and \"Ms.\", from a given locale.\n\nParameters\n\nn::Integer = 1: number of prefixes to generate.\noptions::Vector{<:AbstractString}: vector with options restricting the possible values generated.\nmask::Vector{<:AbstractString}: mask vector with element-wise option restrictions.\n\nOptions\n\nThe valid options values for options and mask are:\n\n\"M\" for \"male\"\n\"F\" for \"female\"\n\nKwargs\n\nlocale::Vector{String}: locale(s) from which entries are sampled. If no locale is provided, the current session locale is used.\n\nExample\n\njulia> prefix([\"female\", \"male\", \"female\"])\n3-element Vector{String}:\n\"Ms.\"\n\"Mr.\"\n\"Ms.\"\n\n\n\n\n\n","category":"function"},{"location":"providers/identity/#Impostor.birthdate","page":"Identity","title":"Impostor.birthdate","text":"birthdate(n::Integer = 1; start::Date, stop::Date)\n\nGenerate n birth date entries between the start and stop dates.\n\nParameters\n\nn::Int = 1: number of dates to generate.\nstart::Date = Date(1900, 1, 1): start of the sampling period.\nstop::Date = Dates.today(): end of the sampling period.\n\n\n\n\n\n","category":"function"},{"location":"providers/identity/#Impostor.bloodtype","page":"Identity","title":"Impostor.bloodtype","text":"bloodtype(n::Integer = 1)\n\nGenerate n blood type entries e.g. \"AB-\", \"O+\" and \"A+\".\n\nParameters\n\nn::Integer = 1: number blood type entries to be generated\n\n\n\n\n\n","category":"function"},{"location":"providers/identity/#Impostor.complete_name","page":"Identity","title":"Impostor.complete_name","text":"complete_name(n::Integer = 1; kwargs...)\ncomplete_name(sexes::Vector{<:AbstractString}, n::Integer; kwargs...)\ncomplete_name(sexes::Vector{<:AbstractString}; kwargs...)\n\nGenerate n or length(mask) full (complete) names from a given locale.\n\nParameters\n\nn::Integer = 1: number of complete names to generate.\n\nOptions\n\nThe valid options values for options and mask are:\n\n\"M\" for \"male\"\n\"F\" for \"female\"\n\nKwargs\n\nmax_surnames::Integer = 3: maximum number of surnames in each of the generated entries, note that the actual number may be smaller than max_surnames.\nlocale::Vector{String}: locale(s) from which entries are sampled. If no locale is provided, the current session locale is used.\n\nExamples\n\njulia> Impostor.complete_name([\"F\"], 5)\n5-element Vector{String}:\n\"Melissa Sheffard\"\n\"Kate Collins\"\n\"Melissa Cornell Fraser\"\n\"Abgail Cornell\"\n\"Abgail Fraser Jameson\"\n\njulia> complete_name([\"F\", \"M\", \"F\", \"F\", \"M\"])\n5-element Vector{String}:\n\"Melissa Sheffard Jameson Cornell\"\n\"Alfred Collins\"\n\"Mary Sheffard Fraser\"\n\"Milly Jameson Fraser\"\n\"Alfred Fraser Collins\"\n\n\n\n\n\n","category":"function"},{"location":"providers/identity/#Impostor.highschool","page":"Identity","title":"Impostor.highschool","text":"highschool(n::Integer = 1; kwargs...)\n\nParameters\n\nn::Integer = 1: number of highschool names to generate.\n\nKwargs\n\nlocale::Vector{String}: locale(s) from which entries are sampled. If no locale is provided, the current session locale is used.\n\n\n\n\n\n","category":"function"},{"location":"providers/identity/#Impostor.nationality","page":"Identity","title":"Impostor.nationality","text":"nationality(n::Integer = 1; kwargs...)\nnationality(options::Vector{<:AbstractString}, n::Integer; level::Symbol, kwargs...)\nnationality(mask::Vector{<:AbstractString}; level::Symbol, kwargs...)\n\nParameters\n\nn::Integer = 1: number of nationality entries to generate.\noptions::Vector{<:AbstractString}: vector with options restricting the possible values generated.\nmask::Vector{<:AbstractString}: mask vector with element-wise option restrictions.\n\nKwargs\n\nlevel::Symbol = :district_name: Level of values in options or mask when using option-based or mask-based eneration. Valid level values are:\n:sex\n:country_code\nlocale::Vector{String}: locale(s) from which entries are sampled. If no locale is provided, the current session locale is used.\n\n\n\n\n\n","category":"function"},{"location":"providers/identity/#Impostor.university","page":"Identity","title":"Impostor.university","text":"university(n::Integer = 1; kwargs...)\nuniversity(fields::Vector{<:AbstractString}, n::Integer; kwargs...)\nuniversity(field_mask::Vector{<:AbstractString}; kwargs...)\n\nParameters\n\nn::Integer = 1: number of university entries to generate.\noptions::Vector{<:AbstractString}: vector with options restricting the possible values generated.\nmask::Vector{<:AbstractString}: mask vector with element-wise option restrictions.\n\nOptions\n\nThe valid options values for elements in options and mask are:\n\n\"business\"\n\"humanities\"\n\"social-sciences\"\n\"natural-sciences\"\n\"formal-sciences\"\n\"public-administration\"\n\"military\"\n\nKwargs\n\nlocale::Vector{String}: locale(s) from which entries are sampled. If no locale is provided, the current session locale is used.\n\n\n\n\n\n","category":"function"},{"location":"providers/identity/#Impostor.occupation","page":"Identity","title":"Impostor.occupation","text":"occupation(n::Integer = 1; kwargs...)\noccupation(options::Vector{<:AbstractString}, n::Integer; kwargs...)\noccupation(mask::Vector{<:AbstractString}; kwargs...)\n\nGenerate n or length(mask) occupation entries.\n\nParameters\n\nn::Integer = 1: number of prefixes to generate.\noptions::Vector{<:AbstractString}: vector with options restricting the possible values generated.\nmask::Vector{<:AbstractString}: mask vector with element-wise option restrictions.\n\nOptions\n\nThe valid options values for the elements in options and mask are:\n\n\"business\"\n\"humanities\"\n\"social-sciences\"\n\"natural-sciences\"\n\"formal-sciences\"\n\"public-administration\"\n\"military\"\n\nKwargs\n\nlocale::Vector{String}: locale(s) from which entries are sampled. If no locale is provided, the current session locale is used.\n\n\n\n\n\n","category":"function"},{"location":"providers/identity/#Impostor.firstname","page":"Identity","title":"Impostor.firstname","text":"firstname(n::Integer = 1; kwargs...)\nfirstname(sexes::Vector{<:AbstractString}, n::Integer; kwargs...)\nfirstname(sexes::Vector{<:AbstractString}; kargs...))\n\nGenerate n or length(mask) first names.\n\nParameters\n\nn::Integer = 1: number of first names to generate.\noptions::Vector{<:AbstractString}: vector with options restricting the possible values generated.\nmask::Vector{<:AbstractString}: mask vector with element-wise option restrictions.\n\nOptions\n\nThe valid options values for options and mask are:\n\n\"M\" for \"male\"\n\"F\" for \"female\"\n\nKwargs\n\nlocale::Vector{String}: locale(s) from which entries are sampled. If no locale is provided, the current session locale is used.\n\nExamples\n\njulia> firstname([\"F\"], 4)\n4-element Vector{String}:\n\"Sophie\"\n\"Abgail\"\n\"Sophie\"\n\"Mary\"\n\njulia> firstname([\"F\", \"M\", \"F\", \"F\", \"M\"])\n5-element Vector{String}:\n\"Sophie\"\n\"Carl\"\n\"Milly\"\n\"Amanda\"\n\"John\"\n\n\n\n\n\n","category":"function"},{"location":"providers/identity/#Impostor.surname","page":"Identity","title":"Impostor.surname","text":"surname(n::Integer = 1; kwargs...)\n\nGenerate a surname using the provided locale as source.\n\nParameters\n\nn::Integer = 1: number of surnames to generate.\n\nKwargs\n\nlocale::Vector{String}: locale(s) from which entries are sampled. If no locale is provided, the current session locale is used.\n\n\n\n\n\n","category":"function"},{"location":"providers/identity/","page":"Identity","title":"Identity","text":"","category":"page"},{"location":"api_reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"Pages = [\n    \"providers/finance.md\",\n    \"providers/identity.md\",\n    \"providers/localization.md\",\n    \"core/utilities.md\",\n]\nDepth = 1\nOrder = [:function]","category":"page"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"providers/localization/#Localization","page":"Localization","title":"Localization","text":"","category":"section"},{"location":"providers/localization/","page":"Localization","title":"Localization","text":"The following generator functions are available in the Localization provider:","category":"page"},{"location":"providers/localization/","page":"Localization","title":"Localization","text":"address\naddress_complement\ncity\ncountry\ncountry_code\ndistrict\npostcode\nstate\nstate_code\nstreet\nstreet_suffix\nstreet_prefix","category":"page"},{"location":"providers/localization/#Impostor.address","page":"Localization","title":"Impostor.address","text":"address(n::Integer = 1; kwargs...)\naddress(options::Vector{<:AbstractString}, n::Integer = 1; level::Symbol, kwargs...)\naddress(mask::Vector{<:AbstractString}; level::Symbol, kwargs...)\n\nParameters\n\nn::Integer = 1: number of addresses to generate.\noptions::Vector{<:AbstractString}: vector with options restricting the possible values generated.\nmask::Vector{<:AbstractString}: mask vector with element-wise option restrictions.\n\nKwargs\n\nlevel::Symbol = :district_name: option level to be used when using option-based generation. Valid level values are:\n:country_code\n:state_code\n:city_name\n:district_name\nlocale::Vector{String}: locale(s) from which entries are sampled. If no locale is provided, the current session locale is used.\n\n\n\n\n\n","category":"function"},{"location":"providers/localization/#Impostor.address_complement","page":"Localization","title":"Impostor.address_complement","text":"address_complement(n::Integer = 1; kwargs...)\n\nParameters\n\nn::Integer = 1: number of address complements to generate.\n\nKwargs\n\nlocale::Vector{String}: locale(s) from which entries are sampled. If no locale is provided, the current session locale is used.\n\n\n\n\n\n","category":"function"},{"location":"providers/localization/#Impostor.city","page":"Localization","title":"Impostor.city","text":"city(n::Integer = 1; kwargs...)\ncity(options::Vector{<:AbstractString}, n::Integer; level, kwargs...)\ncity(mask::Vector{<:AbstractString}; level::Symbol, kwargs...)\n\nParameters\n\nn::Integer = 1: number of country codes to generate.\noptions::Vector{<:AbstractString}: vector with options restricting the possible values generated.\nmask::Vector{<:AbstractString}: mask vector with element-wise option restrictions.\n\nKwargs\n\nlevel::Symbol = :city_name: Level of values in options or mask when using option-based or mask-based eneration. Valid level values are:\n:country_code\n:state_code\n:city_name\nlocale::Vector{String}: locale(s) from which entries are sampled. If no locale is provided, the current session locale is used.\n\n\n\n\n\n","category":"function"},{"location":"providers/localization/#Impostor.country","page":"Localization","title":"Impostor.country","text":"country(n::Integer = 1; kwargs...)\ncountry(options::Vector{<:AbstractString}, n::Integer; level::Symbol, kwargs...)\ncountry(mask::Vector{<:AbstractString}; level::Symbol, kwargs...)\n\nGenerate n or length(mask) country names.\n\nParameters\n\nn::Integer = 1: number of country name entries to generate.\noptions::Vector{<:AbstractString}: vector with with options restricting the possible values generated.\nmask::Vector{<:AbstractString}: mask vector with element-wise option restrictions.\n\nKwargs\n\nlevel::Symbol = :country_code: Level of values in options or mask when using option-based or mask-based generation. Valid level values are:\n:country_code\nlocale::Vector{String}: locale(s) from which entries are sampled. If no locale is provided, the current session locale is used.\n\n\n\n\n\n","category":"function"},{"location":"providers/localization/#Impostor.country_code","page":"Localization","title":"Impostor.country_code","text":"country_code(n::Integer = 1; kwargs...)\ncountry_code(options::Vector{<:AbstractString}, n::Integer; level::Symbol, kwargs...)\ncountry_code(mask::Vector{<:AbstractString}; level::Symbol, keargs...)\n\nGenerate n or length(mask) country codes.\n\nParameters\n\nn::Integer = 1: number of country codes to generate.\noptions::Vector{<:AbstractString}: vector with options restricting the possible values generated.\nmask::Vector{<:AbstractString}: mask vector with element-wise option restrictions.\n\nKwargs\n\nlevel::Symbol = :country_code: Level of values in options or mask when using option-based or mask-based eneration. Valid level values are:\n:country_code\nlocale::Vector{String}: locale(s) from which entries are sampled. If no locale is provided, the current session locale is used.\n\n\n\n\n\n","category":"function"},{"location":"providers/localization/#Impostor.district","page":"Localization","title":"Impostor.district","text":"district(n::Integer = 1; kwargs...)\ndistrict(options::Vector{<:AbstractString}, n::Integer; level::Symbol, kwargs...)\ndistrict(mask::Vector{<:AbstractString}; level::Symbol, kwargs...)\n\nParameters\n\nn::Integer = 1: number of district names to generate.\noptions::Vector{<:AbstractString}: vector with options restricting the possible values generated.\nmask::Vector{<:AbstractString}: mask vector with element-wise option restrictions.\n\nKwargs\n\nlevel::Symbol = :district_name: Level of values in options or mask when using option-based or mask-based eneration. Valid level values are:\n:country_code\n:state_code\n:city_name\n:district_name\nlocale::Vector{String}: locale(s) from which entries are sampled. If no locale is provided, the current session locale is used.\n\n\n\n\n\n","category":"function"},{"location":"providers/localization/#Impostor.postcode","page":"Localization","title":"Impostor.postcode","text":"postcode(n::Integer = 1; kwargs...)\n\nParameters\n\nn::Integer = 1: number of postcodes to generate.\n\nKwargs\n\nlocale::Vector{String}: locale(s) from which entries are sampled. If no locale is provided, the current session locale is used.\n\n\n\n\n\n","category":"function"},{"location":"providers/localization/#Impostor.state","page":"Localization","title":"Impostor.state","text":"state(n::Integer = 1; kwargs...)\nstate(options::Vector{<:AbstractString}, n::Integer; level::Symbol, kwargs...)\nstate(mask::Vector{<:AbstractString}; level::Symbol, kwargs...)\n\nParameters\n\nn::Integer = 1: number of country codes to generate.\noptions::Vector{<:AbstractString}: vector with options restricting the possible values generated.\nmask::Vector{<:AbstractString}: mask vector with element-wise option restrictions.\n\nKwargs\n\nlevel::Symbol = :state_code: Level of values in options or mask when using option-based or mask-based eneration. Valid level values are:\n:country_code\n:state_code\nlocale::Vector{String}: locale(s) from which entries are sampled. If no locale is provided, the current session locale is used.\n\n\n\n\n\n","category":"function"},{"location":"providers/localization/#Impostor.state_code","page":"Localization","title":"Impostor.state_code","text":"state_code(n::Integer = 1; kwargs...)\nstate_code(options::Vector{<:AbstractString}, n::Integer; level::Symbol, kwargs...)\nstate_code(mask::Vector{<:AbstractString}; level::Symbol, kwargs...)\n\nParameters\n\nn::Integer = 1: number of state codes to generate.\noptions::Vector{<:AbstractString}: vector with options restricting the possible values generated.\nmask::Vector{<:AbstractString}: mask vector with element-wise option restrictions.\n\nKwargs\n\nlevel::Symbol = :state_code: Level of values in options or mask when using option-based or mask-based eneration. Valid level values are:\n:country_code\n:state_code\nlocale::Vector{String}: locale(s) from which entries are sampled. If no locale is provided, the current session locale is used.\n\n\n\n\n\n","category":"function"},{"location":"providers/localization/#Impostor.street","page":"Localization","title":"Impostor.street","text":"street(n::Integer = 1; kwargs...)\n\nGenerate n street names.\n\nKwargs\n\nlocale::Vector{String}: locale(s) from which entries are sampled. If no locale is provided, the current session locale is used.\n\n\n\n\n\n","category":"function"},{"location":"providers/localization/#Impostor.street_suffix","page":"Localization","title":"Impostor.street_suffix","text":"street_suffix(n::Integer = 1; kwargs...)\n\nKwargs\n\nlocale::Vector{String}: locale(s) from which entries are sampled. If no locale is provided, the current session locale is used.\n\n\n\n\n\n","category":"function"},{"location":"providers/localization/#Impostor.street_prefix","page":"Localization","title":"Impostor.street_prefix","text":"street_prefix(n::Integer = 1; kwargs...)\n\nKwargs\n\nlocale::Vector{String}: locale(s) from which entries are sampled. If no locale is provided, the current session locale is used.\n\n\n\n\n\n","category":"function"},{"location":"providers/localization/","page":"Localization","title":"Localization","text":"","category":"page"},{"location":"core/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"core/internals/","page":"Internals","title":"Internals","text":"Impostor.coerse_string_type\nImpostor._load!\nImpostor._materialize_template\nImpostor._materialize_numeric_template\nImpostor._materialize_numeric_range_template","category":"page"},{"location":"core/internals/#Impostor.coerse_string_type","page":"Internals","title":"Impostor.coerse_string_type","text":"coerse_string_type(v::Vector{<:AbstractString}) :: Union{String, Vector{String}}\n\nAutomatically unpack the return value of a generator function into a single string, when appropriate.\n\nParameters\n\nv::Vector{<:AbstractString}: value(s) returned by some generator function.\n\nExample\n\njulia> Impostor.coerse_string_type([\"Mark\"])\n\"Mark\"\n\njulia> Impostor.coerse_string_type([\"Mark\", \"Jane\"])\n2-element Vector{String}:\n \"Mark\"\n \"Jane\"\n\n\n\n\n\n","category":"function"},{"location":"core/internals/#Impostor._load!","page":"Internals","title":"Impostor._load!","text":"_load!(provider::T, content::T, locale::Vector{T}) :: DataFrame where {T <: AbstractString}\n_load!(provider::T, content::T, locale::T = \"noloc\") :: DataFrame where {T <: AbstractString}\n\nFetch from the data archive the content associated to the provided locale and provider. Data is returned as a DataFrame for further manipulation. Optionally provide locale = \"noloc for the specific contents without any locale assocated to them.\n\nParameters\n\nprovider::AbstractString: provider name, e.g. \"localization\".\ncontent::AbstractString: content name, e.g. \"street_prefix\".\nlocale::Union{AbstractString, Vector{AbstractString}}: locale(s) associated to the content and provider provided.\n\n\n\n\n\n","category":"function"},{"location":"core/internals/#Impostor._materialize_template","page":"Internals","title":"Impostor._materialize_template","text":"_materialize_template(template::String; locale::String) :: String\n_materialize_template(template::String, reference_dfrow::DataFrames.DataFrameRow; locale::String) :: String\n\n\n\n\n\n","category":"function"},{"location":"core/internals/#Impostor._materialize_numeric_template","page":"Internals","title":"Impostor._materialize_numeric_template","text":"_materialize_numeric_template(template::String) :: String\n_materialize_numeric_template(template::AbstractString, number::Integer) :: String\n\nReceive a numeric template string (e.g. \"###-#\") and generate a string replacing the '#' chars by random integers between [0, 9]; pass fixed numbers in the numeric template (e.g. \"(15) 9####-####\") to pre-select the numbers in the returned string.\n\nOptionally, provide a number to fill the placeholders '#' in template. In this usage, the number of digits in number may be greater of equal to the number of '#' in template, but not smaller.\n\nExamples\n\njulia> Impostor._materialize_numeric_template(\"####-#\")\n\"1324-8\"\n\njulia> Impostor._materialize_numeric_template(\"1/####-9\")\n\"1/5383-9\"\n\njulia> Impostor._materialize_numeric_template(\"####-#\", 12345)\n\"1234-5\"\n\njulia> Impostor._materialize_numeric_template(\"1/####-9\", 4321)\n\"1/4321-9\"\n\njulia> Impostor._materialize_numeric_template(\"####\", 87654321)\n\"8765\"\n\n\n\n\n\n","category":"function"},{"location":"core/internals/#Impostor._materialize_numeric_range_template","page":"Internals","title":"Impostor._materialize_numeric_range_template","text":"_materialize_numeric_range_template(template::AbstractString) :: String\n\nGenerate a string containing a number from a numeric range template. Such numeric templates may contain options separated by a ';' caracter. Additionally, options can assume a single template format (e.g. \"4##\") or specify a range using the ':' character inside the option (e.g. \"2##:3##\" specifies numbers between 200 and 399).\n\nExample\n\njulia> Impostor._materialize_numeric_range_template(\"4#####\")\n\"412345\"\n\njulia> Impostor._materialize_numeric_range_template(\"34####;37####\")  # will select 34#### or 37####\n\"349790\"\n\njulia> Impostor._materialize_numeric_range_template(\"51####:55####\")\n\"532489\"\n\njulia> Impostor._materialize_numeric_range_template(\"2221##:2720##;51####:55####\")  # will select 2221##:2720## or 51####:55####\n\"250000\"\n\n\n\n\n\n","category":"function"},{"location":"core/internals/","page":"Internals","title":"Internals","text":"","category":"page"},{"location":"core/utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"core/utilities/","page":"Utilities","title":"Utilities","text":"The following utility functions are available:","category":"page"},{"location":"core/utilities/","page":"Utilities","title":"Utilities","text":"setlocale!\nresetlocale!\nprovider_exists\ncontent_exists\nlocale_exists","category":"page"},{"location":"core/utilities/#Impostor.setlocale!","page":"Utilities","title":"Impostor.setlocale!","text":"setlocale!(loc::String)\nsetlocale!(locs::Vector{<:AbstractString})\n\nSet loc as the default locale for the current session.\n\n\n\n\n\n","category":"function"},{"location":"core/utilities/#Impostor.resetlocale!","page":"Utilities","title":"Impostor.resetlocale!","text":"resetlocale!()\n\nReset the current session locale to \"en_US\".\n\n\n\n\n\n","category":"function"},{"location":"core/utilities/#Impostor.provider_exists","page":"Utilities","title":"Impostor.provider_exists","text":"provider_exists(p::AbstractString) :: Bool\n\nReturn whether the provided p is available.\n\nParameters\n\np::AbstractString: provider name\n\n\n\n\n\n","category":"function"},{"location":"core/utilities/#Impostor.content_exists","page":"Utilities","title":"Impostor.content_exists","text":"content_exists(p::T, c::T) :: Bool where {T <: AbstractString}\n\nReturn whether the content c is available for provider p.\n\nParameters\n\np::AbstractString: provider name\nc::AbstractString: content name\n\n\n\n\n\n","category":"function"},{"location":"core/utilities/#Impostor.locale_exists","page":"Utilities","title":"Impostor.locale_exists","text":"locale_exists(p::T, c::T, l::T) :: Bool where {T <: AbstractString}\n\nReturn whether the provided locale l is available for content c from provider p.\n\nParameters\n\np::AbstractString: provider name\nc::AbstractString: content name\nl::AbstractString: locale name\n\n\n\n\n\n","category":"function"},{"location":"core/utilities/","page":"Utilities","title":"Utilities","text":"","category":"page"},{"location":"developer_guide/#Developer-Guide","page":"Developer Guider","title":"Developer Guide","text":"","category":"section"},{"location":"developer_guide/","page":"Developer Guider","title":"Developer Guider","text":"This guide aims to provide a general overview of the internals of Impostor.jl. Some of the topics covered in this page are:","category":"page"},{"location":"developer_guide/","page":"Developer Guider","title":"Developer Guider","text":"High-level view of the functionality segregation.\nOrganization of data files used to generate the entries.\nHow to add new data to the package.\nHow to implement new generator-functions.","category":"page"},{"location":"developer_guide/#Design-and-Structure","page":"Developer Guider","title":"Design and Structure","text":"","category":"section"},{"location":"developer_guide/","page":"Developer Guider","title":"Developer Guider","text":"Impostor doesn't magically generates valid names, street names, addreses or credit card numbers out of thin air, of course. Its generation process is based on the information contained in several .csv files structured according to which provider, content and locale each data refers to.","category":"page"},{"location":"developer_guide/","page":"Developer Guider","title":"Developer Guider","text":"Roughly speaking, when a user calls the generator function states([\"BRA\", \"USA\"], 20; level = :country_code) Impostor will internally fetch .csv data files with information about country codes and states, apply the appropriate filters and return correct number of generated entries respecting the restrictions imposed during the call of states.","category":"page"},{"location":"developer_guide/","page":"Developer Guider","title":"Developer Guider","text":"The following figure depicts the data-flow process as a user requests the generation ","category":"page"},{"location":"developer_guide/","page":"Developer Guider","title":"Developer Guider","text":"graph LR\n    subgraph Data Backend \n        direction LR\n        A[.csv 1] --- B\n        Z[.csv 2] --- B\n        X[.csv 3] --- B\n        Y[.csv 4] --- B\n        W[.csv n] --- B[_load!]\n        B --> D[data_interface.jl]\n    end\n    subgraph Package Internals \n        direction LR\n        G1[generator function 1]\n        D --> \n        G2[generator function 2]\n        G3[generator function 3]\n        G4[generator function n]\n    end\n\n    G2 --> Ge[Generated Entries]","category":"page"},{"location":"developer_guide/","page":"Developer Guider","title":"Developer Guider","text":"The steps performed in this generation process can be broken down in two main \"components\":","category":"page"},{"location":"developer_guide/","page":"Developer Guider","title":"Developer Guider","text":"Data Backend: responsable for lazily loading the contents, ensuring consistency between the requests and maintaining the structure of the data archive. It is also its responsability to verify the existance of the requested data files erroring when they are not available.\nPackage Internals: serves as a client for the data backend, this component is responsible selecting the appropriate data files to be loaded and manipulate their contents to comply with the generator-function call restrictions when applicable (e.g. option-based or mask-based loading).","category":"page"},{"location":"developer_guide/#Archive-Organization","page":"Developer Guider","title":"Archive Organization","text":"","category":"section"},{"location":"developer_guide/","page":"Developer Guider","title":"Developer Guider","text":"The information contained in each of the .csv files is read into a DataFrame and stored in an internal structure vaguely called DataContainer. This struct encapsultes a list of currently selected locales for the Session Locale and a dictionary with sub-directories pointing to loaded DataFrames containing data consumed by the generator functions. The key-value structure used by this dictionary matches the organization of the .csv files under the src/data/ directory as follows:","category":"page"},{"location":"developer_guide/","page":"Developer Guider","title":"Developer Guider","text":"src/data/\n    <provider>/\n        <content>/\n            HEADER.txt\n            en_US.csv\n            pt_BR.csv\n            ...\n            en_UK.csv","category":"page"},{"location":"developer_guide/","page":"Developer Guider","title":"Developer Guider","text":"In the structure above:","category":"page"},{"location":"developer_guide/","page":"Developer Guider","title":"Developer Guider","text":"provider encapsulates the associated Provider, e.g. Localization\ncontent stores the .csv files for a given Content, e.g. state codes. Each .csv content file is named after the locale it refers to.\nHEADER.txt is a text file storing exclusively names of columns for all files stored in the src/data/<provider>/<content>/ directory, one column name per line. This file ensures column naming consistency across all locales and prevents individual files from needlessly repeating the same column names. For that reason, every .csv file must contain only the associated data, leaving headers for the respective HEADER.txt files.","category":"page"},{"location":"developer_guide/","page":"Developer Guider","title":"Developer Guider","text":"The interface between the data file structure shown above and the generator functions is stablished by the Impostor._load! method, which serves as a single point of access to all information stored in the src/data/ directory. When a generator-function internally calls","category":"page"},{"location":"developer_guide/","page":"Developer Guider","title":"Developer Guider","text":"Impostor._load!(\"localization\", \"state\", \"en_US\")","category":"page"},{"location":"developer_guide/","page":"Developer Guider","title":"Developer Guider","text":"the structured archive is checked for the existance of a \"state\" content in the \"localization\" provider associated to the United States english (\"en_US\") locale. If such file is available, a DataFrame object is returned with the associated data for further manipulation. Since the column names for a given (\"localization\", \"state\") tuple are restricted by design, multiple locales may be loaded at once:","category":"page"},{"location":"developer_guide/","page":"Developer Guider","title":"Developer Guider","text":"Impostor._load!(\"localization\", \"state\", [\"en_US\", \"pt_BR\"])","category":"page"},{"location":"developer_guide/","page":"Developer Guider","title":"Developer Guider","text":"note: Note on Implementation\nThe Impostor._load! is designed in such way that the DataFrames loaded in each interaction with the archive are memoized to prevent reading the same information more than once per session. This functionality is aided by the functions present in the Utilities page.","category":"page"},{"location":"developer_guide/#Adding-New-Data","page":"Developer Guider","title":"Adding New Data","text":"","category":"section"},{"location":"developer_guide/","page":"Developer Guider","title":"Developer Guider","text":"In order to add new data files, contents or providers, carefully follow the same directory structure described in the previous section paying attention to the format of the HEADER.txt file. Some of the scenarios you will find while adding new data to the archive are shown below:","category":"page"},{"location":"developer_guide/","page":"Developer Guider","title":"Developer Guider","text":"Incrementing existing locale files: corresponds to the simplest case, just add new rows to the respective .csv file. Typically, to ease navigation for users adding new data, the .csv are usually sorted by some of its columns, make your changes so that this property is kept in the modified file.\nAdding new contents or providers: in both cases the creation of a new directory/set of directories is needed. Although this my be slightly subjective, try to do it so that the new set of directories resambles the current organization structure in data/.","category":"page"},{"location":"developer_guide/#Adding-New-Functions","page":"Developer Guider","title":"Adding New Functions","text":"","category":"section"},{"location":"developer_guide/","page":"Developer Guider","title":"Developer Guider","text":"Some guide-lines on adding new generator-functions are:","category":"page"},{"location":"developer_guide/","page":"Developer Guider","title":"Developer Guider","text":"Make sure that that contents required for the new generator-function are available under the data archive in src/data/. If not, then proceed to the previous section on adding new data.\nUse exclusively the Impostor._load! to interact with the data archive. In order to manipulate the dataframe(s) according to your needs, the functions exported by DataFrames.jl should suffice most use cases.\nAdd the new generator-function to the export list in the src/Impostor.jl in the appropriate Provider grouping. Make sure to add it in alphabetical order in each group.\nAdd docstrings with examples, when possible.","category":"page"},{"location":"developer_guide/#Testing-Philosophy","page":"Developer Guider","title":"Testing Philosophy","text":"","category":"section"},{"location":"developer_guide/","page":"Developer Guider","title":"Developer Guider","text":"Tests in Impostor are split in two categories: implementation correctness tests (the usual case for virtually all unit-tested codebases); and data integrity tests which ensure that properties of  data in each .csv are respected for each locale, content and provider. In this context, the testing philosophy used by this package is that:","category":"page"},{"location":"developer_guide/","page":"Developer Guider","title":"Developer Guider","text":"If the contents of datafiles are exhaustively tested for consistency, then testing generator-functions becames a matter of ensuring output formatting correctness.","category":"page"},{"location":"developer_guide/","page":"Developer Guider","title":"Developer Guider","text":"In this context, testing for consistency means that some set of validations is performed upon the files in src/data/ expecting to verify if the newly added data produces any unexpected behavior on the generator-function side of things.","category":"page"},{"location":"developer_guide/","page":"Developer Guider","title":"Developer Guider","text":"","category":"page"},{"location":"#What-is-Impostor.jl?","page":"Introduction","title":"What is Impostor.jl?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Impostor is a synthetic tabular-data generator based on random samplings over pre-defined values. Its structure and design allows for extense customization when generating data.","category":"page"},{"location":"#Avaliable-Providers","page":"Introduction","title":"Avaliable Providers","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"providers/identity.md\",\n    \"providers/finance.md\",\n    \"providers/localization.md\",\n]\nDepth = 1","category":"page"},{"location":"#Getting-Started","page":"Introduction","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"First of all, let't make sure that the Impostor package is installed:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg; Pkg.add(\"Impostor\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To get started with Impostor, select your generator function of choice, the simplest example is to generate single and multiple values specifying the number of expected values in the output.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Impostor # hide\nfirstname()  # equivalent to firstname(1)\nfirstname(5)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nWhen a single value is produced by the generator function, as in firstname(1) from the example above, the returned valued is automatically unpacked into a String (or other applicable type depending on the generator function) instead of being returned as a Vector with exactly 1 element.This behavior might change in future releases.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"All generator functions accept a locale keyword argument, in case no value is provided in the locale kwarg the Session Locale is used (see section Concepts below).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Impostor # hide\nfirstname(2; locale = [\"pt_BR\"])\nfirstname(2; locale = [\"en_US\", \"pt_BR\"])","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In order to change the default locale used by the session use the setlocale! function:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Impostor # hide\nfirstname(2)\nsetlocale!([\"pt_BR\"]);\nfirstname(2)","category":"page"},{"location":"#Concepts","page":"Introduction","title":"Concepts","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"In order to facilitate naming and referencing later on the major concepts implemented are described below:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Generator Functions: are the users' main point of interaction when generating data, every function exported by Impostor which produces data is a generator function.\nProviders: are the broader domain in which the contents and generator functions are organized. For example some of the available providers in Impostor are Finance, Identity and Localization.\nContents: correspond to the specific intermediate kinds of data available for generator-functions to manipulate. For example, within the Localization provider, some of the available contents are street_format, street_prefix and street_suffix which are combined by the generator-functions like address and street to produce entries returned to the user.\nLocales determine the locale domain from which the each content is sampled in its respective generator function. For example, generating data with firstname(5; locale=[\"pt_BR\"]) will generate the content \"firstname\" from the provider \"Identity\" corresponding to names typical to the brazillian portuguese language. \nSession Locale: corresponds to the default locale used by the generator functions when no locale is explicitly provided as a kwarg. The session locale can be set at any time with the setlocale! function, taking on also multiple values for the session locale, e.g. setlocale!([\"pt_BR\", \"en_US\"]).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Impostor Convention for Julia's Multiple-Dispatch\nThe convention followed by Impostor throughout its API is to rely on Julia's multiple-dispatch paradigm and provide users with 3 different methods for (almost) all generator functions. Such methods adhere to the following convention:Implementation Method Signature Desctiption\nValue-based func(n::Int) Simply generate an output with n entries produced by func.\nOption-based func(v::Vector, n::In) This approach will generate an output with n entries produced by the generator function func but restricting the generated entries to the specified options in v, which specific contents will depend on func. Generator functions taking on options in different levels accept the optionlevel kwarg, when it is the case, docstrings will explain each specific behavior.\nMask-based func(v::Vector) This approach will generate an output with length(v) entries produced by the generator function func. The contents of v specify element-wise options to restrict the output of func. Equivalent in terms of output with calling [func(opt, 1) for opt in v] (i.e. the option-based generation), but sub-optimal in terms of performance. Generator functions taking on masks in different levels accept the masklevel kwarg, when it is the case, docstrings will explain each specific behavior.using Impostor # hide\nfirstname(3)  # value-based generation\nfirstname([\"F\"], 3)  # option-based generation\nfirstname([\"F\", \"M\", \"F\", \"M\"])  # mask-based generation","category":"page"},{"location":"#Contributing","page":"Introduction","title":"Contributing","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Contributions are welcome, both in implementation, documentation and data addition to the static files.  Don't hesitate to reach out and request features, file issues or make any suggestions.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For the specific cases of contributing with code and/or data addition, we strongly suggest that you skim though the Developer Guide in order to get familiar with the structure and overall design of the package.","category":"page"},{"location":"#Roadmap","page":"Introduction","title":"Roadmap","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Future developments in Impostor.jl will target the addition of different providers such as:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Business\nBusiness name\nBusiness field\nTechnology\nIPV4/6\nMAC address\nFile extension\nVendor\nDevice\nContact\nE-mail\nUsername\nPhone number\nSocial media\nColor","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}
